the current status of the compiler is:


    1909102.033504:
        
            
                reworked the llvm ir instruction parser code, made it way simplier.
                    

                    we need to figure out how to remap a function, allow the pointer to point to a complextely different set of instructions, with a different signature/name of the func as well.


                        
                        i know its possible.


                        next after that, we should probably figure out how to do llvm symbol table conversions:


                            1. we need to make the transition back and forth from llvm and n3zqx2l very smooth.


                            2, we need to make the llvm symbol table essentially one of the most important central parts of the symbol table.

                            

                            3. we need to make CSR work well with llvm ir strings, llvm types, the llvm symbol table, 
                                    and most importantly, 

                                                llvm CODE GEN:   

                                                    - llvm ir for function calls:      simply a call instruction, with fast calling convention- no respect for C calling convetion.... who cares.
                                                    - llvm ir for _define:         usally a         %t = type {}      as well as a function dfeinition.
                                                    - llvm ir for _dislclose:  usually a GEP ins.
                                                    - llvm ir for string literals.....?













    1909091.164524:
        
            the solution which i found is:
                

                        simply interpret the expression list as a block whos type is the type of the last expression. 
                            
                                for type inference and checking, we need to use the last expression int he list.
                                    

                                        
                     the part we are implementing now, is to make the csr function have two parts:
                        
                            1. csr_single(): parsesa  single expression.

                            2. csr(): parses a series of expressions, using the last one as the type of the whole set. 
                                


                      we realized that the traverse, and the resolve frontends both take expression lists, and operate on them eclusively, basically.
                            


                      finally, we figured out that we need to:      (eventually)
                        

                            1. make a huge change to the typr inference system within csr, 
                                whichis that we need the idea of:     "gradual type-set resolution."

                                        which is simply the idea that we gradually resolve which types a symbol can be, (based on literals, etc....)

                                            as we find it in use of another function, as we continue to parse. 

                                                

                                                we only errror if we find that a given variable was found to have a non singleton type-set (the set of types which are consisntent withthe code.)

                                                    
                                                        
                                                        (however, if the code uses numeric literals, then we will simply pick the word size (assumign its wide enough) to choose a type for numeric literals. )












    1909091.15:
    - we are still working through how to put subexpressions back into csr.

    - we have esssentially decided to make the grammar binary recursive, instead of ternary recursive.
    - - we are going to have blocks of code be delimited by newlines--- tabs are significant only to determine newlines, essentially... i think.

        - definitely want the language be able to use the indentation as the syntactic form. 

            thats really important. 

      


