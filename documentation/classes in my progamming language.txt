
{vector element: anything}: inherited_class [mynamespace, myglobal] {

    ;; this is the type signature. this is within the constructors. the inheritied class is implicitly brought
    ;; in using the [] syntax, no need to put it there.



    .array: [element]*             ;; private by default.

    .count: int                    ;; private by default.

    .capacity: int                 ;; private by default.


    ;; all these must be noted mutable, because there is no code that inits them in this scope.


    (reserve capacity) [.] {

    ;; this function is a method, cuz we're taking in the object ".",
    ;; which is a reference to this object.

    .capacity = capacity            ;; the preceding dot means that its coming from the "this object"


    ;; we could also technically take in other things from the [] thingy. like a whole other global     ;; variable or namespace or something.

    } on creation         ;; implies public, because you cant have a private constructor.
    ;; note: (signature can be "()[.]{}", if you want.

    () [.] {
        print "in destructor!"
    } on destruction


    (= v) [.] {
        .array = v.(get array)
        .capacity = v.(get capacity)
    } on copy


    (this is a static method) {
        print "static method!"
    }
}



(main) {

    v = {}                              ;; best way to declare it. type is infered by the method calls.

    v2: {vector int} = {}              ;; calling empty constructor. (always uses {}, for constructor.)

    v3 = {vector int reserve 5}         ;; this is first calling the template, "{vector int", and then
    ;; calling the constructor, "reserve 5}".

    v.push back 5

    v.this is a static method                      ;; you can call static methods on objects.

    {vector int}.this is a static method          ;; this is good too.    note, this wont create an instance. it will just access

}


