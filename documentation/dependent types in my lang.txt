dependent types in my programming language:









()[]<>{}








:: you can have optional types in function calls, types, concepts, etc...


((add) (multiply) x with y) {

}

[x is mergeable (and sorted)] {
	using x, sorted
}

{[vector T (* capacity: num)]} {    

	 :: the generic parmaeter T has a implicit type, infered by its usecases in the body.
	
}




:: now for dependant types. we want a super set of concepts.

/: what are concepts:


	concepts are compiletime checks of the type.

	dependent types are compiletime checks of the possible values for a type.

	concepts are compiletime checks for whether possible operations on a given type are defined.

	


	


	(add x and y) {
		v: {vector string} = [""]

		return x + y
	}



	{vector T} [T is vectorizable] {


	}


	[x is vectorizable] {
		x == x
		x != x
		x + x
	}


	[sorted x: [comparable]] {
		for i in x,
			if x.prev and x.prev >= x,
				return nothing
	}



	[f: ([comparable])->[sorted [comparable]] does a mergesort] {

		:: adsflaskdjflasjkdfl
	}









code and data 


values (expressions) and functions:


-

expressions deal with m anipulation of values, (specification of values)


type_expressions deal with manipulatin of types, (specifcation of types) (( ie, dependant types ))

-

functions deal with code about that deals with values (expressions)

type functions (aka concepts) deal with code that deals with type (type_expressions)

-















0  1  4  7              (value)

+ - / * %               (functions)



int, string, 


















{vector int}              :: a "function" dealing with types. (a generic container)


(function 5)              :: a function dealing with values.















[x is mergeable with y] {
	(x + y)
	(x == y)
	()

}



from my understanding of cpp concepts, 


they are a list of booleans that needs to be satifisfied, in order for the type to be typchecked succesfully by the compiler.

this also happens to encode hard information about what types we can pass into a function.








concepts are actually a type of type.



if (functions) let you define values, 

and {types} allow you to define types, 

then [concepts] allow you to define types of types, (ie, kinds)










lets rename concepts, to "kinds"






(f) {
    ...
}

{t} {
    ...
}

[k] {
    ...
}


f is a "function".

t is a "type".

k is "kind".



that is the official terminology im going to use in my programming lang.






note:

	- there are "value expressions"

	- and there are "type expressions"

	- AND there are "kind expressions"












ex:


[x is comparable (with y)] {        
	
}







note:


	type expressions       and        value expressiosn:


	int * int + string                true ? 6 * k : 5 + y


	






we need to define a set of type oeprations, which are akin to the the native value operations done on values. (i ripped basically all my value operations from C's syntax.)








logical operations:

	int , int             int also int            x: int, int = (1, 2)

	int + int             int plus int           x: string plus int = ("asdf", 0)

	int | int             int else int           x: int else error = create error

conditional operations:


	type_expression ? int : string             if type_expression, int else string


mathematical operations:



	int - int

	int * int                   ?? should this be the same as  "," ??

	int / int

	int % int


unary operations:

	! int			not int


	& int 			ref int

	* int                   pointer to int 


	. int 		        const int 

	~ int 		        mut int 
	

	- {pointer to int}	restricted {pointer to int}        :: "unqiue"? 

	+ {pointer to int}	shared {pointer to int}













already-made weird types:


	() 			nothing
	
	_ 			anything

	auto			(to be type-interfered)         :: do we need this?

	{} 			code block

	[]		        ???? kinds?







     x: auto = 5               ===          x = 5







ex:

	+.*.int === {shared {const {pointer to {const int}}}} === shared const pointer to const int
	



all of these operations could tehnically be implemented as a "class" (all be it, a hardware "compiler instrinsic" native one, but still )

thus they could all have the {const T}  syntax, if you need to have that.  this is completely valid:



x: {~ string} = "hello"


	:: or simply


x:~ = "hello"                :: this is doing alot more than you think.












note: we can actually do type function overloading, so you know how there is not a nonnull function, right?

that doesnt just have to be defined for pointers.. the user could define it for their class as well, (implemented as a kind???) and then simply say:

v: nonnull vector int = []

and this would work because, even though the type expression predendence wasnt defined, it was irrevelant, because the nonnull type function that was defined is a unary operator, which doesnt need a precedence, unless it conflicts with another unary operator of different "infix/prefix/postfix" category. 




to define nonnull for our vector, we simply say:



[nonnull x: {vector T}] {                     :: note: this wont use the ! ssyntax, only this syntax.

	:: maybe check that the vector is already initialized or something...?
}



this may have been a bad example, but basically we want to be able to define a new kind (type function), which allows us to have more expressivity with our own types in type_expressions, just like how functions allow us to make expressions more expressive.






more examples of a type expression:



d: {pointer to {int + string}} = null


c: {vector int *}









precendence of type_expression operations:



{vector T} [T is vectorizable] <3> {
	

}


types have precendence 0, just like function calls.

kinds also have precedence 0 by default. 

(obviously all of these three things wont really every interact, because they are on different planes of existence?


















that raises a question:


- can we call a value function (a function) in a type_expression?

- - ...in comes dependent types.







x: int > 4 = 3        :: compile time error!

x: pointer to int != null = allocate |int| * 8       :: compiletime error, allocate could return null.

note you CANT overload the |sizeof| operator. its not useful.

note, obviously from this we know that the unary operators ive defined have a higher precedence relative to comparisons, which have a rather low precedence.



x: int > 10 ! + 4 = 5            ::  compiletime error!

this code is dclaring a dependent type, which is only checked (but checked ruthlessly) at compiletime.

its actually calling a compiletime function, (n!), which is pretty cool.


---> so you have use compiletime expressiosn in your types, which is all reduced down to bare metal after compilation.


dependent types, but as fast as C code!

























note, from my understanding,


x: int * int = 3   :: what does * do?

					         :: is much different from,

x: int, int = (1,2)


int and int collapses into just int, technically. 

"x * y" means that type is both of type x, and of type y.

















lets 
	r: algebraic types; 

some more.



















one other thing:


we need to be able to use "kinds" just the same as a type, ie


where ever you can have a type_expression, you should be able to have a kind_expression.




this is analogous to declaraing a var which is of type "function".





























but now that i think of it, it seems that functions are the odd one out in this case.





they are disctintly a transformation on a set of values, which yeilds a set of values.







and then a {type} are distinctly a transformation on a set of types, which yields a new type.


and a kind is a transformation on a set of types (or kinds)




























