concepts can be implemented as 



kinds which take in a type, (which could be of a type, or another kind)





and then return a type.



if the type deoesnt satifsy the requirement, then "nothing" type is returned.


which ends up making the argumetn fail at CT when you try to pass that type in to the {type}.



all this [kind] {...} stuff is evalualted at compiletime.



ex:








[channel T] {
	if open T and close T, 
		return T
	else 
		return nothing	
}

:: note: the semantics of this "function"-like-thing is this:


- if the function returns nothing, that means the type was rejected.

- if the function just returns, that mean it was accepted, and did not specify anything further.

- if the function evaluates an expression that is erroneous, the function returns "nothing" immediately.

thus, we can actually rewrite [channel T] to be:


[channel T] {
	open T
	close T
}

	pretty nice huh?









also note, you can declare "type" variables inside the kind function, which can either be literal types, (int, string, {vector int})  or type of types, (channel, mergeable, and other kinds)







also, i think you can call value functions in kinds, in this lang. this will force a type or kind to bea particular value.

this is sorta like "narrowing"..?

going all the way from KINDS to TYPES to VALUES in oen big swoop.























HIGHER ORDER KINDS??



PASSING KINDS INTO KINDS?


oh wait! return type of a kind!

[] -> []        :: this is a "empty lambda" type signature of a kind.



so a function is a type,

a kind is a type,

a type is a type,

a kind accepts types

a value is of a type

a function accepts values of a type

a type accepts types 

a type accepts values

????

man we gotta draw these relations out...






so anyways, we can pass a kind into a kind, which, now that i think about it...











we can pass functions into kinds!!!


this is extremely powerful, because we essentially get all of "protocols" from Swift, now.


ex:


[f: ([comparable])->([comparable]) sorts] {
	:: verifies that a functions operations yield a particular type, 
	
}








now, the usage of this is the hard part...



(mergesort array: [comparable]) -> ([int]) [???] {
	
}


one idea is for the function to use "." inside a type signature, to mean this function, which would work...

although this would conflict somwwhat with the mandatory usage of "." in types, for accessing itself...


although that isnt so bad actually. 




another better idea though, is to just always have the first argument be the function itself? sure. why not?



(mergesort array) -> [int] [sorts] {        

}



we just need to make sure that when we call a kind function signature, that we make sure that any parameter of the kind which are of type "value_function" are actually optional, if the kind is being called in a function definition.







note:     "."    or     "ourself"     

...really are only found in classes/types. 
functions are not classes/types. they are function.





















note, should it be possible to pass a kind into a ud type? does that even make sense?
would the ud type turn into a kind?

no, thats not very applicable. i think.















note, you can actually declare variables of types "kinds", which will allow the variable to be generic, for all types that satisfy the type requirement:





x: channel = function call with 5 and 6      

 :: "function call with and" better return something thats a channel.






















note with type expressions:        the for loop and the list/iteratable type:



if we take 


	x: [int] = [1,2,3,4,5]              :: how can we specify in the type that this must be sorted?

we coudl do this:

	x: [for x where x.prev <= x] = [1,2,3,6,4,6,7,8]       :: compile time error.
                                                ^~~~~~~~


other examples:

	y: [for x where x == 4] = [4, 4, 4, 4, 4]     :: can only store 4's in this array.











normal for loops: off by one errors, and accessing the previous, next or anything further away:


one idea is to allow the programmer to say:


for i in [1,2,2,4,5] {
	if i.prev and i.prev == i,
		print i	
}

this will print "2".

cool huh!


you can even have i.prev.prev!

and so on.




hmmmmmmmm........ i dont know about this.


















