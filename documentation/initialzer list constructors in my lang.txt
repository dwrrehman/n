really what we mean to say is:



not this:

	v = [vector 1, 2, 3, 4, 5]        :: this is wrong.


but actually:

	v = vector [1, 2, 3, 4, 5,]          ::this is right. uses a initializer list constructor


	but technically you can have a named initializer list, by doing:

	pair_of_vs: {pair {vector int}} = {vector [1,2,3,4], vector [1,2,3,7] }



or if you want to be verbose about it:

	
	v: [vector int] = {vector int [1,2,3,4,5]}

	v:{vector int} = {vector int [1,2,3,4,5]}

	v: vector int = vector int [1,2,3,4,5]

	v: vector int = vector [1,2,3,4,5]

	v: [vector int * 5] = [1,2,3,4,5]          :: reserves the capacity. its redudant in this case.

	v: vector = [1,2,3,4,5]

	v = [1,2,3,4,5]      :: deduced from usage.










IMPORTANT NOTE:


you always need commas in between elements in an initializer list.






further more, you dont need commas inbetween function call arguments:

because you know the function signature, and you know all other function signatures, so its silly to put a comma compulsorily.




however, it should be optional to put a comma after any function parameter which has a function parameter right after it. (it is implcicit in the signature.)


example:

	(function add x y) { ... }

	(x * y) { ... }

	(x is odd) { ... }


function add 5, 6     :: valid        
function add 5 6     :: valid
x is odd              :: valid
x * y			:: valid.

function add 5, 6,     :: invalid
x, is odd		:: invalid.
x, * y			:: invalid.










overloading names:


note: kinds and types must have distinct namespaces.

	ie, you cant have a kind called "vector T"   AND  a type called "vector T"








