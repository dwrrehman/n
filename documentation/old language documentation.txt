;; this is a inline comment.

;: this is a 
    multiline comment. :;



{vector element}: container {        ;; this vector impl will use a concept, "container"!

    using io
    
    array = [1,2,3,4,5,6]

    () constructor {
        for i in [1,2,3,4] {
            print i + 3
        }
    }
    () destructor {
        print "destructing object."
    }
}



(main) {
    print "this is a cool language."
}






;: ------------------ other notes: ----------------------

note that types can have member variables within them, but these variables are prefixed with a dot, that doesnt neccessarily make them mutable.

that is done by making the assignment into:

    x: var = 3         ;; declares x to be a type "mutable something" where the something is determined at compile time.

    y: const = 5        ;; declares y to be a type "const something", the rest is determiend at CT.

            ;; note that the cosnt on y is redundant, as its not changes in this scope.
            ;; however the x might need to have the var qualifer, if you dont modify x in teh scope, but know that you will need to modify it later.

    







    also, we might want to include a syntax for array slicing notation.


    possibly using a member function on arrays.



    array = [1,2,3,4,5,6,7,8,]
    n = array.count                ;; static retreivale of how many elements array has, if its an array type.

    array.(from 0 to n by 1)    ;; gets the whole array,

    






    expressions are not exactly built into the language, they go through the function call syntax as well.

    for instance, the function defintion of plus:

    (a + b) {                       ;; there exists a set of identifier-like operators.
        ;; impl of (a + b)        
    }

    notice that the parenthesis are part of the function signature, formally.

    however, they can be dropped, if the precedence isnt affected.


    ;; ex:

    named_scope {                  ;; this is a named scope.
        print "2+3 = " 2 + 3
    }

    ;; big note: the user can actually define what precedence operations are done, for their own functins? i dont know how they would do this, though...






























:; ----------------------------------------------------
