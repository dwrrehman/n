the current status of the nostril compiler:
=============================================




==================================

		TODO:

==================================


PRIORITY:    
    
    - make csr left associative
    
    - make csr fast in all situations








BUSY WORK:
--------------------

    - rewrite the parsing stage to be a single function.
    
    - rewrite the lexing stage slightly, to be simpler?
        
    - add options list for linker, eventually.
   

 



FIGURE OUT STUFF:
------------------------------------





FUNCTIONS:

x:    - figure out how to pass functions into functions;

    - figure out what function types look like. make them builtin, i think.
    
x:    - figure out how to do closures / lambdas;
    
    - figure out how to specify llvm attributes to a function.


TYPES:        

    - figure out how to do computational type checking properly, 
	as opposed to using subsitutions and everything.

        (ie, do type-related stuff better, and more correctly)
        
    - figure out Henry-Milner Type-Inference.


GENERAL:

    - figure out how to do compiletime evlauation correctly.    
       ...like zig does it..?

    - figure out how to make _define provide _expose functionality         [nice]

    - figure out how we are going to do multiple files, and our module system.





        













test cases that DO work:
=============================

        join declare ((n) (_)) n
      
===============================

        join
        declare ((((x) (_)) ((y) (_))) (_))
        name name

===============================

join (declare ((unit) (_)))
join ( declare ((( (x) (unit) (_) )) (_)) )
join ( declare ((( (x) (_) )) (unit) (_)) )
join ( def ((((first) (unit) (_)) ((second) (unit) (_))) (unit) (_)) unit second)
name name


===============================

    join
    declare ((((x) (_)) ((y) (_))) (_))
    name name


===============================

join declare ((lazy ((x) (_))) (_))
join declare ((push) (_))
join declare ((pop) (_))
join declare
    ((
        ((signature) (name) (_))
        ((type) (_))
        ((definition) (lazy type) (_))
    ) (_))

join declare ((unit) (_)))
join declare ((g) (unit) (_))

name

===============================


(join (declare ((lazy ((x) (_))) (_)))
(join (declare ((push) (_)))
(join (declare ((pop) (_)))
(join (declare (( ((signature) (name) (_)) ((type) (_)) ((definition) (lazy type) (_)) ) (_)))
(join (declare ((unit) (_)))
(join (declare ((g) (unit) (_)))
(((x) unit g))))))))

===============================




join (declare ((unit) (_)))
join (declare ((namef) (unit) (_)))
join ( declare ((( (x) (unit) (_) )) (_)) )
join ( def ((((first) (unit) (_)) ((second) (unit) (_))) (_) ) unit second)
namef namef


===============================


join (declare (( ((x) (_)) ((y) (_))) (_) ))
name name name name name name name

===============================


join (declare ((((x) (_)) hello ((x) (_))) (_)))
(name hello name hello name)


===============================


join (declare ((lazy ((x) (_))) (_)))
join (declare ((push) (_)))
join (declare ((pop) (_)))
join (declare (( ((signature) (name) (_)) ((type) (_))    ((definition) (lazy type) (_)) ) (_)))
join (declare ((namef) (_)))
name

join (declare ((unit) (_)))
join ( declare ((( (x) (unit) (_) )) (_)) )
join ( declare ((( (x) (_) )) (unit) (_)) )
join ( def ((((first) (unit) (_)) ((second) (unit) (_))) (unit) (_)) unit second)
name name


===============================











so the algorithmis always LEFT-ASSOCIATIVE

thats cool.

simplified it slightly... trying to debug why it doesnt work sometimes, though.


        ----> CSR is literally so buggy. this succeeds, with an epmty parse.
        
            we and we cant say the last line without an error...
            
                
                
                    
                    we need to fix csr.   we need to redesign csr to make this language feasible.
                        
                            both in error messages, and in compiler-runtime lag.
                            
                            
                            
                            
                            
                            this language is unuseable, as is.
                            
                                
                                
                                
                                                            


CURRENT TASK DETAILS:
=======================


	fix csr: make it right assoc, and faster.         then you are done!


    
NEXT TASK:
==========================
    
    then after this, we work on codegening:
    
        - start by getting "declare void @"(hello world)"();" to be generated from a define call, with no body.
            ---> figure out how to call define with no body! (no, not using a seperate new intrinsic.)
            
        - then get the generation of an actual n3zqx2l function (from a define) working.
        
        - then get the generation of a call to a (n or ll) function working, with the correct calling convention: fast! (unless we are calling something external? i dont know.)
        
        
    
    
    
===============================================================================================





THE TODO LIST:
=====================

[PRIMARY:]
==========

- allow for ctfe! necc for _def to work.

- add lazy code generation using _a          [neccessary]
- add compiletime evlauation to csr.
- add compiletime parameters
- add compiletime generation of runtime data.

- add resolution based type inference  (or/plus henry milner TI)       [nice]

- figure out how to make _define provide _expose functionality         [nice]

- figure out how we are going to do multiple files, and our module system.         [neccessary]

- make llvms void passable and initiable like the real unit type.    [nice]  [must be done in codegen phase]



[SECONDARY:]
============



- use the updated pass mananger llvm system, for generating .s or .o files, and for optimization.      [self hosting]
- reimplement the compiler using the llvm c-api, which is much more intuitive.             [efficiency]   [self-hosting]

- revise our target triple.                                                                     [efficiency]
- replace all occurences (or hearly all) of std::vector    with    llvm::SmallVector<1000ish, T>.    [efficiency]
- use more of the stl algorithms..?                                                           [efficiency]

- add numberic constants suppport.                                   [nice]
- add codegen and support for text strings in csr and llvm.          [nice]
- code for passing flags to the linker (-!)                          [nice]









=========== found bugs: =====================

    - the compiler doesnt give a warning for an extranous closing parentheiss.
        --> then what happens?
        
        
        
        
        
    
    
    
 
        
        
=============================== CLOSED: ======================
        
        

        ------ NEW bug: -------

        test code:

            join
            declare ((f ((T) (_)) ((x) (T) (_))) (T) (_))
            name

        ;

        we are defining the function, but not printing the retunr type properly, in the debug symbol table.

   
        
    - in the following test code:
    
        _2 (_3 (((() (_)) (() (_))) (_)))
        (_3 ((code (() (_))) (_)) )
        (_3 ((define ((s) (_1) (_)) ((d) (code _1) (_))) (_)) )
        (_3 ((g) (code _1) (_)) )
        define hello g
                
        x: SERIOUS: 1. the compiler defines g twice.;
        
        x: SERIOUS: 2. the compiler doesnt distinguish:            code (_1)     and        code (code (_1));
        
        


    
in the following test code:
    
    join define ((code ((x) (_))) (_))
    join define ((((first) (_)) ((second) (_))) (_))
    (define ((my define ((signature) (name) (_)) ((T) (_)) ((definition) (code (T)) (_))) (_)))

    define ((hello there) (_))
    define ((g) (code hello there) (_)))
    define ((f) (code name) (_)))
    my define hello hello there g
    my define bye name g

    
        this succeeds, when it shouldnt.
    
    
    
    - another bug: in the following test code:
    
    
    join define ((code ((x) (_))) (_))
    join define ((((first) (_)) ((second) (_))) (_))
    (define ((my define ((signature) (name) (_)) ((T) (_)) ((definition) (code (T)) (_))) (_)))


    (define ((hello there) (_)))
    (define ((g) (code hello there) (_))))
    (define ((f) (code name) (_))))
    (my define hello hello there g)
    (my define bye name f)



        this defines g twice.
    
        
=============================================



============ DONE: ===========


x: - code for passing args to the executable (--);
x: we just got _b working basically perfectly, except....;
x: make fdi work with multiple _2 (_b) paraemters.;
x: - get fdi functionality fully working, using _b;
x: - add _0 functionality to csr.;

x: - write the string to expression function.;
x: - get csr working with subexpressions properly.;
x: - make llvm strings nestable.;
x: - possibly get rid ll stirngs. ;
x: - add assembly output functioality,;
x: - figure out how to remove the symbol table data structure.;
x: - redo how we are handsling lexing, ;
x: - devise a better llvm interop system.;
x: - write the define function.;
x: - figure out how to represent llvm elements such as: function and type and value      (or even globals?);    
x: - figure out how define should work;   
x: - make string to expression function cope with llvm-single-identifiers.;    
x: - allow type-section deductions in n3zqx2l signature strings inside llvm strings.;::this is a high bar thing, we are saving it until we do type inference, which is not soon.;

x:
    we need ctfe in order to (properly) allow the user to pass in a type (which may take type parameters!)
        when they give the return type, for a signature,
            when passing a _name (_b).
            
            i know, its alittle bit compilcated, but its neccessary. for both return type, and paraemter types.
            
            we need to use this ctfe infrastruction eventually to write a "find()" function, whch takes in a type list, and turns that into an index.
    
  ;
    
    


==================================








=========================================================================================================================================








2001072.224206:

ok, so we are finally at the place in the compiler where we need to decide exactly how our type system is "computational".
























so we are dramatically simplifying how we are doing our symbol table management, and probably type inference as well.


we might be using something like hentry milner type inference, plus some delayed resolution stuff.

additionally, we will be code gening intstantly into the llvm ir, upon parsing n3zqx2l code.

wait, no, we shouldnt... because of calls to functions:
	
	there is one definition, which we can easily update when we realize its type,

	but there are many instances in which its called, which we need to update as well.

	














our data layout is fine i guess..



redo how we are doing strings.



we shouldnt have sgtring literals.


i feel like we should also make spaces insignificant, but maybe not, actually.


yeah lets not.







so it looks like we have two major tasks as todos for our compiler:


    - make the csr algortihm work with subexpressions,
    
    - redo our idea of how our language integrates with llvm.
    
                this is actually exptremely important.
            
                we need to get this right, in just the right way, and make sure that our implementation is clean and concise.
                
                
                
                
                
    







we really need to get the:


    - csr algortithm working with subexpr
    
    - get the llvm symbol table synched up with our symbol table.
    
    - get the




ok, so we deleted a bunch of code, and the whole compiler is now only 950ish lines long.


the current bug we are trying to solve is trying to get the chain rule to work with our current CSR setup. it was working, and then i changed how subexpressions worked, because i saw a simplication, and not it doesnt work. i might change csr to work as before, just to get it working. its not that great of a simplication.











1. i need to go through and delete all the error.cpp code, and redo all the code as inline print statements, in the logic code.


2. i need to start removing features from CSR, specfically:       strings,         ...

CSR should only have in it:


    - the csr parsing capability
        
    - fdi functionality
    
    - llvm string parsing capability
    
    - 




































1910104.152555:



        current todo:
        
        
            - get string literals working
            
            - get fdi working all the way, for multiple abstraction parameters.
            
            - get resolution based type inference working.
            
            - get the llvm instruction parser working properly, (there is a bug in the aftermath of removing basic blocks, or something.)
            
            - add an intrinsic for giving a warning or error at compiletime to the user.
            
            - 
            
            
        later todo:
        
            - find out if we need _e (expose)
            
            - find out what _c (??) is.
            
            - implement _a (application)
            
            - make sure _b (abstraction) is working.
            
            - get _e (expose) and _d (define) working.
                        
            - add _0 capabilities to the type system: CSR algorithm wise.
            
                - - dont NOT parse an expression which instantiates _0, 
                
                    just give an error afterwards, when we recognize that we cannot do that.
              
            - think about how namespaces are implemented, at the library level.
            
            - think about the capabiltiies of _d (define).
            

        questions: 

        
            - is _1 special other than how we are using it?    (as the type of statements, technically?)
            
            - does the body of soemthing neccessarily have to have a return expression?
            
            - how does compiletime evaluation of parameters, and contraction of code, using llvm optimization, work?
            
            - what do copmiletime parameters look like?
            
            - - is that _c?            no......?
            
            - 

            
            
            - get code gen working with _d 

















1909275.021133:


ok, so what have we just done?


	we almost got string literals working, we just need to make it type check, by

	
		making sure we set the llvm_type member of a particular entry in the master symbol tbale, known as "llvm", 
	


				when it has the type which is i8*, 
	
		then we are able to pass a string into a function.

	
		its a abit weird, but its the only soltion i could come up wiht.
	
	
			
tb:

	
anywaysm i fifured out how to do compiletime execution/population of values to be used at runtime!
	

		just run a function, then get a Generic value back from it, 
	
		then turn that into a actual value (of some type)

	
			and then create a new global variable cosntant, of that new value.	

	
	
		this seems liek it will work in general...
	
	

		we just need to make sure that we do reduction of code at compiletime, as well.	
	
	
		this is possibly the much more COOL aspect of CTAE, 
		

			which is that we can actually simplify parts of logic, which we know can be done at compiletime.	

;



	





1909264.223628:



	so i almost implememnted FDI the other day, which is good...

	however, there are two known bugs:


			- FDI: not being able to pass two differently lengthed signatures into an application.

	
			- parsing llvm instructions:  there is a weird bug with the aftermath of removing the "donothing-unreachables" after parsing the llvm stirngs.


	
		
	

----------- whats next to implememnt? --------------------------------




	
			1.5: csr additions:   
	


		70%		_b     :   "FDI":  passing undefined signatures into expressions: 
				
		0%		_a     :   "CTAE":  compiletime/lazy computation 
							(passing in unealutated expressions.)
	
		0%		__     :   "TI": aggressive candidate-set-resolution-based type inference




			2. string to expression converter


			3. symbol table management, and covnersion between llvm and n.

s	
			4. write the (c++) implementation for:
			
				4.1.    _c    : ???

				4.2.    _d    : IMPORTANT.

				4.3.    _e    : easy: print warning/error/info/note



			5. code generation (cg):	
					
				5.1. cg for _d'efined abstractions: 
					turning into:
						llvm functions
						llvm types
						llvm variables
	
				5.2. cg for evaluated _a's


			6. more compiler options

			
			7. REPL functionality


			8. core standard library    


			9. public exposure!

















1909161.233343:

	ok, so csr, (the "resolver" from here on out)

			is basically totally finished- it can regonize/resolve very complex expressions, and works basically perfectly. (i have yet to find a bug in it)

	
		and i also fixed a bug in the llvm parse instruction function, which had to do with adding terminator instructions, and lone basic blocks being left over, after the annex was removed.
	
				thats all fixed too now!

	

		
			now it seems the right thing to move onto next is symbol conversion:
	
	
		[done]:	1. 	from n3zqx2l to llvm:          (ie, expression to string)         
	
		[todo]:	2. 	from llvm to n3zqx2l:		(ie, string to expression)




	looking at our schedule:



			x:0. llvm string parser;


			x:1. CSR suite;


			1.5: csr additions:   
	
				FDI:  passing signatures into expressions 
	
				TI: aggressive candidate-set-resolution-based type inference


			2. string to expression converter


			3. symbol table management, and covnersion between llvm and n.

s	
			4. write the (c++) implementation for:
			
				4.1.    _a    : no implementation. 
				4.2.    _b    : no implementation. [FDI?]
				4.3.    _c    : easy.
				4.4.    _d    : IMPORTANT.
				4.5.    _e    : easy.
				4.6.    _0    : no implementation. 
				4.7.    _1    : no implementation. 









;















    ok, so i have cleaned up alot of stuff in the code, and basically set everything up for me to just code the new version of csr using 
            
                    resolved expression list
                        
                    resolved expression 

                        
                        data structures.
                            




              once this csr is done, that marks the next stage which is basically symbol table conversions.
                
            

                    this step shouldnt be that hard, assuming i get all my ducks in a row, and realize what i have at my disposal, 

                    becasue:

                        
                            
                                expression_list/expression -> string     is a simple signature serializer

                                string -> expression       will most certaintly be using CSR and the rest of the parsing machinery int he compiler, (including the lexer!) to implement this function. however there is alittle fancy ness in the signature that has to be done. thats the trick part.


                         anyways, this is all so i can just get values back and forth between the llvm symbol tables, and the n3zqx2l symbol tables.


                    
                  ...and then after that, is code gen!

                  which is the fun part!









yeah, im pretty sure that the thing which i have to do now, is figure out how to make CSR actually run properly in my compiler with all my changes. im sure it wont be that hard... i mean its only csr lol.








	1909113.190244:

		so i finished the instruction parser, its prettyy much as simple as possible now.
	
		
	
		the next thing i need to do is figure out how to do csr on a expression_list tree, rather than a expression tree.

	
	so:




			x:0. llvm string parser;

			1. CSR suite

			2. string to expression converter

			3. symbol table management, and covnersion between llvm and n.
	
			4. write the (c++) implementation for:
			
				4.1.    _a    : no implementation. 
				4.2.    _b    : no implementation. [FDI?]
				4.3.    _c    : easy.
				4.4.    _d    : IMPORTANT.
				4.5.    _e    : easy.
				4.6.    _0    : no implementation. 
				4.7.    _1    : no implementation. 










    1909102.033504:
        
            
                reworked the llvm ir instruction parser code, made it way simplier.
                    

                    we need to figure out how to remap a function, allow the pointer to point to a complextely different set of instructions, with a different signature/name of the func as well.


                        
                        i know its possible.


                        next after that, we should probably figure out how to do llvm symbol table conversions:


                            1. we need to make the transition back and forth from llvm and n3zqx2l very smooth.


                            2, we need to make the llvm symbol table essentially one of the most important central parts of the symbol table.

                            

                            3. we need to make CSR work well with llvm ir strings, llvm types, the llvm symbol table, 
                                    and most importantly, 

                                                llvm CODE GEN:   

                                                    - llvm ir for function calls:      simply a call instruction, with fast calling convention- no respect for C calling convetion.... who cares.
                                                    - llvm ir for _define:         usally a         %t = type {}      as well as a function dfeinition.
                                                    - llvm ir for _dislclose:  usually a GEP ins.
                                                    - llvm ir for string literals.....?













    1909091.164524:
        
            the solution which i found is:
                

                        simply interpret the expression list as a block whos type is the type of the last expression. 
                            
                                for type inference and checking, we need to use the last expression int he list.
                                    

                                        
                     the part we are implementing now, is to make the csr function have two parts:
                        
                            1. csr_single(): parsesa  single expression.

                            2. csr(): parses a series of expressions, using the last one as the type of the whole set. 
                                


                      we realized that the traverse, and the resolve frontends both take expression lists, and operate on them eclusively, basically.
                            


                      finally, we figured out that we need to:      (eventually)
                        

                            1. make a huge change to the typr inference system within csr, 
                                whichis that we need the idea of:     "gradual type-set resolution."

                                        which is simply the idea that we gradually resolve which types a symbol can be, (based on literals, etc....)

                                            as we find it in use of another function, as we continue to parse. 

                                                

                                                we only errror if we find that a given variable was found to have a non singleton type-set (the set of types which are consisntent withthe code.)

                                                    
                                                        
                                                        (however, if the code uses numeric literals, then we will simply pick the word size (assumign its wide enough) to choose a type for numeric literals. )












    1909091.15:
    - we are still working through how to put subexpressions back into csr.

    - we have esssentially decided to make the grammar binary recursive, instead of ternary recursive.
    - - we are going to have blocks of code be delimited by newlines--- tabs are significant only to determine newlines, essentially... i think.

        - definitely want the language be able to use the indentation as the syntactic form. 

            thats really important. 

      


